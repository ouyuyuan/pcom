
! Description: i/o and global preparations
!
!      Author: OU Yuyuan <ouyuyuan@lasg.iap.ac.cn>
!     Created: 2015-10-18 20:49:07 BJT
! Last Change: 2015-11-07 10:53:39 BJT

module mod_master

  ! imported variables !{{{1
  use mpi

  use mod_kind, only: wp

  use mod_param, only: &
    nm, &
    myid, mid, &
    glo_ni, glo_nj, glo_nk, &
    ni, nj, nk, nim, njm, nkm

  use mod_io, only: io_get_dim_len, io_read

  use mod_arrays, only: glo_lat, glo_lon, glo_z, &
    type_gv, glo_frc

  implicit none
  private

  public &
    master_initialize, master_write_dim_info, &
    glo_phib, glo_pb, glo_pt, glo_sa, &
    glo_itn, glo_gvu, glo_gvw

  ! exported variables !{{{1
  type (type_gv), allocatable, dimension(:) :: &
    glo_gvu, glo_gvw

  real (kind=wp), allocatable, dimension(:,:,:) :: &
    glo_pt, glo_sa
  real (kind=wp), allocatable, dimension(:,:) :: &
    glo_phib, glo_pb

  integer, allocatable, dimension(:,:) :: &
    glo_itn

  ! local variables !{{{1
  integer :: err, is

contains !{{{1

subroutine master_initialize () !{{{1

  if ( myid == mid ) call initialize ()
  call mpi_barrier (mpi_comm_world, err)

end subroutine master_initialize

subroutine initialize () !{{{1

  use mod_type, only: assignment(=)

  integer :: k

  call read_namelist (nm)

  ! get domain dimension !{{{2
  call io_get_dim_len ( nm%fi, 'lon', glo_ni )
  call io_get_dim_len ( nm%fi, 'lat', glo_nj )
  call io_get_dim_len ( nm%fi, 'z',   glo_nk )

  ! allocate arrays !{{{2

  allocate(glo_pt(glo_ni, glo_nj, glo_nk), stat=is); call chk(is)
  glo_pt = 0.0
  allocate(glo_sa(glo_ni, glo_nj, glo_nk), stat=is); call chk(is)
  glo_sa = 0.0

  ! 12 months boundary forcing
  allocate(glo_frc(glo_ni, glo_nj, 12), stat=is); call chk(is)
  glo_frc%tau = 0.0; glo_frc%ts = 0.0
  glo_frc%slp = 0.0; glo_frc%fw = 0.0

  allocate(glo_pb (glo_ni, glo_nj), stat=is); call chk(is)
  glo_pb = 0.0
  allocate(glo_phib (glo_ni, glo_nj), stat=is); call chk(is)
  glo_phib = 0.0

  allocate(glo_itn(glo_ni, glo_nj), stat=is); call chk(is); glo_itn = 0

  allocate(glo_lat(glo_nj), stat=is); call chk(is); glo_lat = 0.0
  allocate(glo_lon(glo_ni), stat=is); call chk(is); glo_lon = 0.0
  allocate(glo_z  (glo_nk), stat=is); call chk(is); glo_z   = 0.0

  allocate(glo_gvu(glo_nk), stat=is); call chk(is)
  allocate(glo_gvw(glo_nk), stat=is); call chk(is)

  ! read in initial fields !{{{2
  call io_read (nm%fi, 'lon', glo_lon)
  call io_read (nm%fi, 'lat', glo_lat)
  call io_read (nm%fi, 'z',   glo_z)

  call io_read (nm%fi, 'pt',  glo_pt)
  call io_read (nm%fi, 'sa',  glo_sa)

  call io_read (nm%fi, 'itn', glo_itn)

  call io_read (nm%ff, 'taux', glo_frc%tau%x(1)) 
  call io_read (nm%ff, 'tauy', glo_frc%tau%x(2)) 

  call io_read (nm%ff, 'bct', glo_frc%ts%x(1)) 
  call io_read (nm%ff, 'bcs', glo_frc%ts%x(2)) 

  call io_read (nm%ff, 'slp', glo_frc%slp) 

  call io_read (nm%ff, 'fw', glo_frc%fw) 

  ! calc. global variabls {{{2

  call calc_ver (glo_phib, glo_pb, glo_gvu, glo_gvw)

end subroutine initialize 

subroutine calc_ver (glo_phib, glo_pb, gu, gw) !{{{1
  ! calc. sea bottom pressure from mean t-s stratification
  !   tname, sname in input file fname
  !   since vertical properties ofter involve vertical integration, 
  !   we also calc. global grid infonation in vertical direction

  use mod_con, only: rho0, g
  use mod_den, only: den_rho
  use mod_type, only: type_memo

  real (kind=wp), dimension(glo_ni, glo_nj) :: glo_phib, glo_pb
  type (type_gv), dimension(glo_nk) :: gu, gw ! u/w grid info.

  type (type_memo) :: memo

  real (kind=wp), dimension(glo_nk) :: &
    glo_rmn, glo_phimn, glo_pmn, &
    glo_tmn, glo_smn, glo_dz
  integer :: i, j, k

  call io_read (nm%fi, 'tmn', glo_tmn)
  call io_read (nm%fi, 'smn', glo_smn)

  memo % p = 0.0
  memo % c = 1.0

  ! glo_dz, solve the eq. ( dp(k-1) + dp(k) ) / 2 = z(k) - z(k-1)
  glo_dz(1) = 2*glo_z(1)
  glo_phimn(1) = - g * glo_dz(1)
  do k = 2, glo_nk
    glo_dz(k) = 2 * ( glo_z(k) - glo_z(k-1) ) - glo_dz(k-1) 
    glo_phimn(k) = glo_phimn(k-1)  - g * glo_dz(k)
  end do

  glo_rmn(:) = rho0
  do while ( abs(memo % p - memo % c).gt.1e-6 )
    memo % p = memo % c

    glo_pmn(1) = glo_rmn(1) * g * glo_dz(1)
    do k = 2, glo_nk
      glo_pmn(k) = glo_rmn(k) * g * glo_dz(k) + glo_pmn(k-1)
    end do

    do k = 2, glo_nk
      glo_rmn(k) = den_rho ( glo_tmn(k), glo_smn(k), &
        (glo_pmn(k-1) + glo_pmn(k))*0.5 )
    end do
  end do

  do j = 1, glo_nj
  do i = 1, glo_ni
    k = glo_itn(i, j)
    if ( k == 0 ) then
      glo_phib(i,j) = 0.0
      glo_pb(i,j) = 0.0
    else
      glo_phib(i,j) = glo_phimn(k)
      glo_pb(i,j) = glo_pmn(k)
    end if
  end do
  end do

  ! vertical grid info.
  gu(1) % z = glo_z(1)
  gw(1) % z = glo_dz(1)

  gu(1) % x3 = glo_pmn(1)*0.5
  gw(1) % x3 = glo_pmn(1)
  do k = 2, glo_nk
    gu(k) % z = glo_z(k)
    gw(k) % z = gw(k-1)%z + glo_dz(k)

    gu(k) % x3 = ( glo_pmn(k) + glo_pmn(k-1) )*0.5
    gw(k) % x3 = glo_pmn(k)
  end do

end subroutine calc_ver

subroutine read_namelist (nm) !{{{1
  ! read parameters from file namelist, and store them 
  !   in the structure nm

  use mod_param, only: type_nm

  type (type_nm) :: nm

  integer, parameter :: fid_nam = 20

  ! namelist
  integer :: npy, npx, npz

  character (len=80) :: bdate, edate
  integer :: dtbt, dtbc

  character (len=80) :: fname_ini, fname_frc, fname_out, out_per

  ! it can't use the syntax % for namelist /.../ statesment
  !    so we redefine namelist parameters
  ! although we can read in namelist in all processors, 
  ! but it seems the namelist file may be destroyed by 
  ! muliple-opening (happened once)

  namelist /mpi_ctrl/ npy, npx, npz
  namelist /time_ctrl/ bdate, edate, dtbt, dtbc
  namelist /io_ctrl/ fname_ini, fname_frc, fname_out, out_per

  open(fid_nam, file='namelist')
  read(fid_nam, mpi_ctrl)
  read(fid_nam, time_ctrl)
  read(fid_nam, io_ctrl)
  close(fid_nam)

  ! check integrated time step

  if ( mod(24*60*60, dtbt) /= 0 ) stop &
    'barotropic time step dtbt should be divided by seconds in a day'

  if ( mod(24*60*60, dtbc) /= 0 ) stop &
    'baroclinic time step dtbc should be divided by seconds in a day'

  if ( mod(dtbc, dtbt) /=0 ) stop &
    'baroclinic time step dtbc should be divived by barotropic time step dtbt'

  nm%py = npy
  nm%px = npx
  nm%pz = npz

  nm%bd = bdate
  nm%ed = edate
  nm%bt = dtbt
  nm%bc = dtbc

  nm%fi = fname_ini
  nm%ff = fname_frc
  nm%fo = fname_out
  nm%per= out_per

end subroutine read_namelist

subroutine master_write_dim_info (fid) !{{{1
  integer, intent(in) :: fid

  if ( myid == mid ) call write_dim_info (fid)
end subroutine master_write_dim_info

subroutine write_dim_info (fid) !{{{1

  integer, intent(in) :: fid

    write( fid, '(a, i4, a, i2, a, i3, a)' )   &
      'glo_ni = ', glo_ni, ' with ', nm%px,          &
      ' processors in the x-direction, and ni approximate ', &
      nim, ' for the sub-domain.'

    write( fid, '(a, i4, a, i2, a, i3, a)' )   &
      'glo_nj = ', glo_nj, ' with ', nm%py,          &
      ' processors in the y-direction, and nj approximate ', &
      njm, ' for the sub-domain.'

    write( fid, '(a, i4, a, i2, a, i3, a)' )   &
      'glo_nk = ', glo_nk, ' with ', nm%pz,          &
      ' processors in the z-direction, and nk approximate ', &
      nkm, ' for the sub-domain.'

    write( fid, * ) ''

end subroutine write_dim_info

subroutine chk( ista ) !{{{1
  ! check state of allocate array 

  integer, intent(in) ::  ista

  if ( ista /= 0 ) then
    write(*,*) 'Allocate array failed. Stop'
    stop 2
  end if
end subroutine chk

end module mod_master!{{{1
!-------------------------------------------------------{{{1
! vim:fdm=marker:fdl=0:
! vim:foldtext=getline(v\:foldstart).'...'.(v\:foldend-v\:foldstart):
