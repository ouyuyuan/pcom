! Description: mpi related routine
!   if nm%px = 4, nm%py = 2, then id matrix is:
!     (NOTE that east-west direction is wrap up)
!
!   0 4
!   1 5
!   2 6
!   3 7
!
!      Author: OU Yuyuan <ouyuyuan@lasg.iap.ac.cn>
!     Created: 2015-09-14 14:25:29 BJT
! Last Change: 2015-10-28 19:07:55 BJT

module mod_mympi

  ! imported variables !{{{1
  use mpi
  use mod_kind, only: wp

  use mod_param, only: nm, mid, myid, np, &
    glo_nj, glo_ni, glo_nk, ni, nj, nk, &
    gpw, gpws, gpz, type_gpw

  use mod_type, only: type_accu_r3d

  use mod_io, only: io_print, io_write, io_quick_output

  implicit none
  private

  ! interfaces !{{{1
  public &
    mympi_div, &
    mympi_swpbnd, &
    mympi_fix_integrate, &
    mympi_pass_baton, &
    mympi_diffuse_z, &
    mympi_recvsend_up, &
    mympi_recvsend_down, &
    mympi_quick_output, &
    mympi_allreduce_z, &
    mympi_bcast, &
    mympi_bcast_s2z, &
    mympi_output

  interface mympi_bcast
    module procedure bcast_i
    module procedure bcast_i2
    module procedure bcast_i3
    module procedure bcast_string
    module procedure bcast_str2
  end interface

  interface mympi_allreduce_z
    module procedure allreduce_z_r2d
    module procedure allreduce_z_i2d
  end interface

  interface mympi_quick_output
    module procedure quick_output_r2d
    module procedure quick_output_r1d
    module procedure quick_output_i2d
  end interface

  interface mympi_div
    module procedure div_r3d
    module procedure div_r2d
    module procedure div_r1d
    module procedure div_i3d
    module procedure div_i2d
  end interface

  interface mympi_swpbnd
    module procedure swpbnd_r3d
    module procedure swpbnd_r2d
    module procedure swpbnd_r1d
    module procedure swpbnd_i3d
    module procedure swpbnd_i2d
  end interface

  interface mympi_output
    module procedure merge_out_r3d
  end interface

  ! local variables !{{{1
  integer :: is, err, msta(mpi_status_size)

contains !{{{1

subroutine bcast_i (var)!{{{1
  ! broadcast var from mid to all ids
  integer :: var

  call mpi_bcast(var, 1, mpi_integer, mid, mpi_comm_world, err)

end subroutine bcast_i

subroutine bcast_i2 (va, vb)!{{{1
  ! broadcast vars from mid to all ids
  integer :: va, vb

  call bcast_i (va)
  call bcast_i (vb)

end subroutine bcast_i2

subroutine bcast_i3 (va, vb, vc)!{{{1
  ! broadcast vars from mid to all ids
  integer :: va, vb, vc

  call bcast_i (va)
  call bcast_i (vb)
  call bcast_i (vc)

end subroutine bcast_i3

subroutine bcast_string (var)!{{{1
  ! broadcast var from mid to all ids
  character (len=*) :: var

  call mpi_bcast(var, len(var), mpi_byte, mid, mpi_comm_world, err)
end subroutine bcast_string

subroutine bcast_str2 (va, vb)!{{{1
  ! broadcast vars from mid to all ids
  character (len=*) :: va, vb

  call bcast_string (va)
  call bcast_string (vb)
end subroutine bcast_str2

subroutine mympi_bcast_s2z (var) !{{{1
  ! broadcast var in the surface (id is 0) to others in gpz
  real (kind=wp), dimension(ni,nj) :: var

  call mpi_bcast(var, ni*nj, mpi_real8, 0, gpz%c, err)

end subroutine mympi_bcast_s2z

subroutine allreduce_z_r2d (va, vb) !{{{1
  ! allreduce va to vb in vertical group gpz
  real (kind=wp), dimension(ni,nj) :: va, vb
  call mpi_allreduce ( va, vb, ni*nj, mpi_real8, &
                       mpi_sum, gpz%c, err)
end subroutine allreduce_z_r2d

subroutine allreduce_z_i2d (va, vb) !{{{1
  ! allreduce va to vb in vertical group gpz
  integer, dimension(ni,nj) :: va, vb
  call mpi_allreduce ( va, vb, ni*nj, mpi_integer, &
                       mpi_sum, gpz%c, err)
end subroutine allreduce_z_i2d

subroutine merge_out_r3d (fname, varname, var) !{{{1
  ! merge 3d array from other domains to mid
  character (len=*) :: fname, varname
  type (type_accu_r3d) :: var

  real (kind=wp), allocatable, dimension(:,:,:) :: glo_var

  integer, parameter :: tag = 30
  type (type_gpw) :: d
  integer :: n, leng

  if (myid == mid) then

    allocate( glo_var(glo_ni, glo_nj, glo_nk), stat=is)
    call chk(is); glo_var = 0.0

    do n = 1, np
      d = gpws(n)
      leng  = (d%ge-d%gw+1) * (d%gn-d%gs+1) * (d%gl-d%gu+1)
      if ( d%id == mid ) then
        glo_var(d%gw:d%ge, d%gs:d%gn, d%gu:d%gl) = &
          var % p(2:d%ni-1, 2:d%nj-1, 2:d%nk-1)
      else
        call mpi_recv (glo_var(d%gw:d%ge,d%gs:d%gn,d%gu:d%gl), &
          leng, mpi_real8, d%id, tag, mpi_comm_world, msta, err)
      end if
    end do

    glo_var(:,:,:) = glo_var(:,:,:) / var%n ! time-average

    call io_write (trim(fname), trim(varname), glo_var, var%nrec + 1)

  else
    leng  = (gpw%ge-gpw%gw+1) * (gpw%gn-gpw%gs+1) * (gpw%gl-gpw%gu+1)
    call mpi_ssend (var%p(2:gpw%ni-1,2:gpw%nj-1,2:gpw%nk-1), leng, &
      mpi_real8, mid, tag, mpi_comm_world, err)
  end if

  var % p(:,:,:) = 0.0 ! reset accumulated value
  var % n = 0 ! reset counter
  var % nrec = var % nrec + 1 ! nc record

end subroutine merge_out_r3d

subroutine quick_output_r2d (fname, varname, var) !{{{1
  ! merge 2d array from other domains to mid and output
  character (len=*) :: fname, varname
  real (kind=wp), intent(in) :: var(:,:)

  real (kind=wp), allocatable, dimension(:,:) :: glo_var

  integer, parameter :: tag = 30
  type (type_gpw) :: d
  integer :: n, leng

  if (myid == mid) then

    allocate( glo_var(glo_ni, glo_nj), stat=is)
    call chk(is); glo_var = 0.0

    do n = 1, np
      d = gpws(n)
      leng = (d%ge-d%gw+1) * (d%gn-d%gs+1)
      if ( d%id == myid ) then
        glo_var(d%gw:d%ge, d%gs:d%gn) = var(2:d%ni-1, 2:d%nj-1)
      else
        call mpi_recv (glo_var(d%gw:d%ge,d%gs:d%gn), &
          leng, mpi_real8, d%id, tag, mpi_comm_world, msta, err)
      end if
    end do

    call io_quick_output (trim(fname), trim(varname), glo_var)

  else
    leng = (gpw%ge-gpw%gw+1) * (gpw%gn-gpw%gs+1)
    call mpi_ssend (var(2:gpw%ni-1,2:gpw%nj-1), leng, &
      mpi_real8, mid, tag, mpi_comm_world, err)
  end if

end subroutine quick_output_r2d

subroutine quick_output_r1d (fname, varname, var, c) !{{{1
  ! merge 2d array from other domains to mid and output
  character (len=*), intent(in) :: fname, varname
  character (len=1), intent(in) :: c
  real (kind=wp), intent(in) :: var(:)

  if ( c.eq.'y' ) then
    call output_r1d_y (fname, varname, var)
  else if ( c.eq.'x' ) then
    call output_r1d_x (fname, varname, var)
  else if ( c.eq.'z' ) then
    call output_r1d_z (fname, varname, var)
  else
    stop 'unhandled character in quick_output_r1d in mod_mympi'
  end if

end subroutine quick_output_r1d

subroutine output_r1d_y (fname, varname, var) !{{{1
  ! merge 1d array from other domains to mid and output
  character (len=*), intent(in) :: fname, varname
  real (kind=wp), intent(in) :: var(:)

  real (kind=wp), allocatable, dimension(:) :: glo_var

  integer, parameter :: tag = 140
  type (type_gpw) :: d
  integer :: n, leng

  if (myid == mid) then
    allocate( glo_var(glo_nj), stat=is)
    call chk(is); glo_var = 0.0

    do n = 1, np
      d = gpws(n)
      leng = d%nj - 2
      if ( d%id == myid ) then
        glo_var(d%gs:d%gn) = var(2:d%nj-1)
      else
        call mpi_recv (glo_var(d%gs:d%gn), &
          leng, mpi_real8, d%id, tag, mpi_comm_world, msta, err)
      end if
    end do
    call io_quick_output (trim(fname), trim(varname), glo_var, 'y')

  else
    leng = gpw%nj - 2
    call mpi_ssend (var(2:gpw%nj-1), leng, &
      mpi_real8, mid, tag, mpi_comm_world, err)
  end if

end subroutine output_r1d_y

subroutine output_r1d_x (fname, varname, var) !{{{1
  ! merge 1d array from other domains to mid and output
  character (len=*), intent(in) :: fname, varname
  real (kind=wp), intent(in) :: var(:)

  real (kind=wp), allocatable, dimension(:) :: glo_var

  integer, parameter :: tag = 150
  type (type_gpw) :: d
  integer :: n, leng

  if (myid == mid) then
    allocate( glo_var(glo_ni), stat=is)
    call chk(is); glo_var = 0.0

    do n = 1, np
      d = gpws(n)
      leng = d%ni - 2
      if ( d%id == myid ) then
        glo_var(d%gw:d%ge) = var(2:d%ni-1)
      else
        call mpi_recv (glo_var(d%gw:d%ge), &
          leng, mpi_real8, d%id, tag, mpi_comm_world, msta, err)
      end if
    end do
    call io_quick_output (trim(fname), trim(varname), glo_var, 'x')

  else
    leng = gpw%ni - 2
    call mpi_ssend (var(2:gpw%ni-1), leng, &
      mpi_real8, mid, tag, mpi_comm_world, err)
  end if

end subroutine output_r1d_x

subroutine output_r1d_z (fname, varname, var) !{{{1
  ! merge 1d array from other domains to mid and output
  character (len=*), intent(in) :: fname, varname
  real (kind=wp), intent(in) :: var(:)

  real (kind=wp), allocatable, dimension(:) :: glo_var

  integer, parameter :: tag = 160
  type (type_gpw) :: d
  integer :: n, leng

  if (myid == mid) then
    allocate( glo_var(glo_nk), stat=is)
    call chk(is); glo_var = 0.0

    do n = 1, np
      d = gpws(n)
      leng = d%nk - 2
      if ( d%id == myid ) then
        glo_var(d%gu:d%gl) = var(2:d%nk-1)
      else
        call mpi_recv (glo_var(d%gu:d%gl), &
          leng, mpi_real8, d%id, tag, mpi_comm_world, msta, err)
      end if
    end do
    call io_quick_output (trim(fname), trim(varname), glo_var, 'z')

  else
    leng = gpw%nk - 2
    call mpi_ssend (var(2:gpw%nk-1), leng, &
      mpi_real8, mid, tag, mpi_comm_world, err)
  end if

end subroutine output_r1d_z

subroutine quick_output_i2d (fname, varname, var) !{{{1
  ! merge 2d array from other domains to mid and output
  character (len=*) :: fname, varname
  integer, intent(in) :: var(:,:)

  integer, allocatable :: glo_var(:,:)

  integer, parameter :: tag = 50
  type (type_gpw) :: d
  integer :: n, leng

  if (myid == mid) then

    allocate( glo_var(glo_ni, glo_nj), stat=is)
    call chk(is); glo_var = 0

    do n = 1, np
      d = gpws(n)
      leng = (d%ge-d%gw+1) * (d%gn-d%gs+1)
      if ( d%id == myid ) then
        glo_var(d%gw:d%ge, d%gs:d%gn) = var(2:gpw%ni-1, 2:gpw%nj-1)
      else
        call mpi_recv (glo_var(d%gw:d%ge,d%gs:d%gn), &
          leng, mpi_integer, d%id, tag, mpi_comm_world, msta, err)
      end if
    end do

    call io_quick_output (trim(fname), trim(varname), glo_var)

  else
    leng = (gpw%ge-gpw%gw+1) * (gpw%gn-gpw%gs+1)
    call mpi_ssend (var(2:gpw%ni-1,2:gpw%nj-1), leng, &
      mpi_integer, mid, tag, mpi_comm_world, err)
  end if

end subroutine quick_output_i2d

subroutine swpbnd_r3d (var) !{{{1
  ! swap the boundary of subdomain for 3d array

  real (kind=wp) :: var(:,:,:)

  call swpbnd_h_r3d (var)

  call swpbnd_v_r3d (var)

end subroutine swpbnd_r3d

subroutine swpbnd_h_r3d (var) !{{{1
  ! horizontally swap the boundary of subdomain for 3d array

  real (kind=wp) :: var(:,:,:)

  integer, parameter :: tag = 10
  integer :: leng

  ! also include (i+1,j+1,k+1) as boundary 
  leng = gpw%nj * gpw%nk

  ! eastward
  call mpi_sendrecv (var(gpw%ni-1,:,:), leng, mpi_real8, &
    gpw % e, tag, var(1,:,:), leng, mpi_real8, &
    gpw % w, tag, mpi_comm_world, msta, err)

  ! westward
  call mpi_sendrecv (var(2,:,:), leng, mpi_real8, &
    gpw % w, tag, var(gpw%ni,:,:), leng, mpi_real8, &
    gpw % e, tag, mpi_comm_world, msta, err)

  leng = gpw%ni * gpw%nk

  ! northward
  call mpi_sendrecv (var(:,gpw%nj-1,:), leng, mpi_real8, &
    gpw % n, tag, var(:,1,:), leng, mpi_real8, &
    gpw % s, tag, mpi_comm_world, msta, err)

  ! southward
  call mpi_sendrecv (var(:,2,:), leng, mpi_real8, &
    gpw % s, tag, var(:,gpw%nj,:), leng, mpi_real8, &
    gpw % n, tag, mpi_comm_world, msta, err)

end subroutine swpbnd_h_r3d

subroutine swpbnd_v_r3d (var) !{{{1
  ! vertically swap the boundary of subdomain for 3d array

  real (kind=wp) :: var(:,:,:)

  integer, parameter :: tag = 10
  integer :: leng

  leng = gpw%ni * gpw%nj

  ! upward
  call mpi_sendrecv (var(:,:,2), leng, mpi_real8, &
    gpw % u, tag, var(:,:,gpw%nk), leng, mpi_real8, &
    gpw % l, tag, mpi_comm_world, msta, err)

  ! downward
  call mpi_sendrecv (var(:,:,gpw%nk-1), leng, mpi_real8, &
    gpw % l, tag, var(:,:,1), leng, mpi_real8, &
    gpw % u, tag, mpi_comm_world, msta, err)

end subroutine swpbnd_v_r3d

subroutine swpbnd_r2d (var) !{{{1
  ! horizontally swap the boundary of subdomain for 2d array

  real (kind=wp) :: var(:,:)

  integer, parameter :: tag = 110
  integer :: leng

  leng = gpw%nj

  ! eastward
  call mpi_sendrecv (var(gpw%ni-1,:), leng, mpi_real8, &
    gpw % e, tag, var(1,:), leng, mpi_real8, &
    gpw % w, tag, mpi_comm_world, msta, err)

  ! westward
  call mpi_sendrecv (var(2,:), leng, mpi_real8, &
    gpw % w, tag, var(gpw%ni,:), leng, mpi_real8, &
    gpw % e, tag, mpi_comm_world, msta, err)

  leng = gpw%ni

  ! northward
  call mpi_sendrecv (var(:,gpw%nj-1), leng, mpi_real8, &
    gpw % n, tag, var(:,1), leng, mpi_real8, &
    gpw % s, tag, mpi_comm_world, msta, err)

  ! southward
  call mpi_sendrecv (var(:,2), leng, mpi_real8, &
    gpw % s, tag, var(:,gpw%nj), leng, mpi_real8, &
    gpw % n, tag, mpi_comm_world, msta, err)

end subroutine swpbnd_r2d

subroutine swpbnd_r1d (var, c) !{{{1
  ! vertically swap the boundary of subdomain for 3d array

  real (kind=wp) :: var(:)
  character (len=1) :: c

  integer, parameter :: tag = 60
  integer, parameter :: leng = 1


  if ( c.eq.'x' ) then
    ! eastward
    call mpi_sendrecv (var(gpw%ni-1), leng, mpi_real8, &
      gpw % e, tag, var(1), leng, mpi_real8, &
      gpw % w, tag, mpi_comm_world, msta, err)

    ! westward
    call mpi_sendrecv (var(2), leng, mpi_real8, &
      gpw % w, tag, var(gpw%ni), leng, mpi_real8, &
      gpw % e, tag, mpi_comm_world, msta, err)

  else if ( c.eq.'y' ) then
    ! northward
    call mpi_sendrecv (var(gpw%nj-1), leng, mpi_real8, &
      gpw % n, tag, var(1), leng, mpi_real8, &
      gpw % s, tag, mpi_comm_world, msta, err)

    ! southward
    call mpi_sendrecv (var(2), leng, mpi_real8, &
      gpw % s, tag, var(gpw%nj), leng, mpi_real8, &
      gpw % n, tag, mpi_comm_world, msta, err)

  else if ( c.eq.'z' ) then
    ! upward
    call mpi_sendrecv (var(2), leng, mpi_real8, &
      gpw % u, tag, var(gpw%nk), leng, mpi_real8, &
      gpw % l, tag, mpi_comm_world, msta, err)

    ! downward
    call mpi_sendrecv (var(gpw%nk-1), leng, mpi_real8, &
      gpw % l, tag, var(1), leng, mpi_real8, &
      gpw % u, tag, mpi_comm_world, msta, err)

  else
    stop 'unhandled direction indicator in swpbnd_r1d'
  end if

end subroutine swpbnd_r1d

subroutine swpbnd_i3d (var) !{{{1
  ! swap the boundary of subdomain for 3d array

  integer :: var(:,:,:)

  call swpbnd_h_i3d (var)

  call swpbnd_v_i3d (var)

end subroutine swpbnd_i3d

subroutine swpbnd_i2d (var) !{{{1
  ! horizontally swap the boundary of subdomain for 2d array

  integer :: var(:,:)

  integer, parameter :: tag = 90
  integer :: leng

  leng = gpw%nj

  ! eastward
  call mpi_sendrecv (var(gpw%ni-1,:), leng, mpi_integer, &
    gpw % e, tag, var(1,:), leng, mpi_integer, &
    gpw % w, tag, mpi_comm_world, msta, err)

  ! westward
  call mpi_sendrecv (var(2,:), leng, mpi_integer, &
    gpw % w, tag, var(gpw%ni,:), leng, mpi_integer, &
    gpw % e, tag, mpi_comm_world, msta, err)

  leng = gpw%ni

  ! northward
  call mpi_sendrecv (var(:,gpw%nj-1), leng, mpi_integer, &
    gpw % n, tag, var(:,1), leng, mpi_integer, &
    gpw % s, tag, mpi_comm_world, msta, err)

  ! southward
  call mpi_sendrecv (var(:,2), leng, mpi_integer, &
    gpw % s, tag, var(:,gpw%nj), leng, mpi_integer, &
    gpw % n, tag, mpi_comm_world, msta, err)

end subroutine swpbnd_i2d

subroutine swpbnd_h_i3d (var) !{{{1
  ! horizontally swap the boundary of subdomain for 3d array

  integer :: var(:,:,:)

  integer, parameter :: tag = 10
  integer :: leng

  leng = gpw%nj * gpw%nk

  ! eastward
  call mpi_sendrecv (var(gpw%ni-1,:,:), leng, mpi_integer, &
    gpw % e, tag, var(1,:,:), leng, mpi_integer, &
    gpw % w, tag, mpi_comm_world, msta, err)

  ! westward
  call mpi_sendrecv (var(2,:,:), leng, mpi_integer, &
    gpw % w, tag, var(gpw%ni,:,:), leng, mpi_integer, &
    gpw % e, tag, mpi_comm_world, msta, err)

  leng = gpw%ni * gpw%nk

  ! northward
  call mpi_sendrecv (var(:,gpw%nj-1,:), leng, mpi_integer, &
    gpw % n, tag, var(:,1,:), leng, mpi_integer, &
    gpw % s, tag, mpi_comm_world, msta, err)

  ! southward
  call mpi_sendrecv (var(:,2,:), leng, mpi_integer, &
    gpw % s, tag, var(:,gpw%nj,:), leng, mpi_integer, &
    gpw % n, tag, mpi_comm_world, msta, err)

end subroutine swpbnd_h_i3d

subroutine swpbnd_v_i3d (var) !{{{1
  ! vertically swap the boundary of subdomain for 3d array

  integer :: var(:,:,:)

  integer, parameter :: tag = 10
  integer :: leng

  leng = gpw%ni * gpw%nj

  ! upward
  call mpi_sendrecv (var(:,:,2), leng, mpi_integer, &
    gpw % u, tag, var(:,:,gpw%nk), leng, mpi_integer, &
    gpw % l, tag, mpi_comm_world, msta, err)

  ! downward
  call mpi_sendrecv (var(:,:,gpw%nk-1), leng, mpi_integer, &
    gpw % l, tag, var(:,:,1), leng, mpi_integer, &
    gpw % u, tag, mpi_comm_world, msta, err)

end subroutine swpbnd_v_i3d

function div_r3d (glo_var) !{{{1
  ! distribute 3d array from mid to other domains

  real (kind=wp), dimension(:,:,:), intent(in) :: glo_var

  real (kind=wp), dimension(gpw%ni, gpw%nj, gpw%nk):: div_r3d

  integer, parameter :: tag = 20
  type (type_gpw) :: d
  integer :: n, leng

  div_r3d = 0.0

  if (myid == mid) then

    do n = 1, np
      d = gpws(n)
      leng = (d%ni - 2) * (d%nj - 2) * (d%nk - 2)
      if ( d%id == mid ) then
        div_r3d(2:gpw%ni-1, 2:gpw%nj-1, 2:gpw%nk-1) = &
          glo_var(d%gw:d%ge, d%gs:d%gn, d%gu:d%gl)
      else
        call mpi_ssend (glo_var(d%gw:d%ge,d%gs:d%gn,d%gu:d%gl), &
          leng, mpi_real8, d%id, tag, mpi_comm_world, err)
      end if
    end do

  else
    leng = (gpw%ni - 2) * (gpw%nj - 2) * (gpw%nk - 2)
    call mpi_recv (div_r3d(2:gpw%ni-1,2:gpw%nj-1,2:gpw%nk-1), &
      leng, mpi_real8, mid, tag, mpi_comm_world, msta, err)
  end if

  call swpbnd_r3d (div_r3d)

end function div_r3d

function div_r2d (glo_var) !{{{1
  ! distribute 2d array from mid to other domains

  real (kind=wp), dimension(:,:), intent(in) :: glo_var

  real (kind=wp), dimension(gpw%ni, gpw%nj) :: div_r2d

  integer, parameter :: tag = 90
  type (type_gpw) :: d
  integer :: n, leng

  div_r2d = 0.0

  if (myid == mid) then
    do n = 1, np
      d = gpws(n)
      leng = (d%ni - 2) * (d%nj - 2)
      if ( d%id == mid ) then
        div_r2d(2:gpw%ni-1, 2:gpw%nj-1) = glo_var(d%gw:d%ge, d%gs:d%gn)
      else
        call mpi_ssend (glo_var(d%gw:d%ge,d%gs:d%gn), &
          leng, mpi_real8, d%id, tag, mpi_comm_world, err)
      end if
    end do

  else
    leng = (gpw%ni - 2) * (gpw%nj - 2)
    call mpi_recv (div_r2d(2:gpw%ni-1,2:gpw%nj-1), leng, mpi_real8, &
      mid, tag, mpi_comm_world, msta, err)
  end if

  call swpbnd_r2d (div_r2d)

end function div_r2d

function div_r1d (glo_var, c) !{{{1
  ! distribute 1d array from mid to other domains

  real (kind=wp), dimension(:), intent(in) :: glo_var
  character (len=1), intent(in) :: c

  real (kind=wp), allocatable, dimension(:) :: div_r1d

  if      ( c.eq.'y' ) then
    allocate( div_r1d(gpw%nj), stat=is ); call chk(is)
    div_r1d = div_r1d_y (glo_var)

  else if ( c.eq.'x' ) then
    allocate( div_r1d(gpw%ni), stat=is ); call chk(is)
    div_r1d = div_r1d_x (glo_var)

  else if ( c.eq.'z' ) then
    allocate( div_r1d(gpw%nk), stat=is ); call chk(is)
    div_r1d = div_r1d_z (glo_var)

  else
    stop 'unhandled character in div_r1d input parameter in module mod_mympi'
  end if

end function div_r1d

function div_r1d_y (glo_var) !{{{1
  ! distribute 1d array from mid to other domains

  real (kind=wp), dimension(glo_nj), intent(in) :: glo_var
  real (kind=wp), dimension(gpw%nj) :: div_r1d_y

  integer, parameter :: tag = 50
  type (type_gpw) :: d
  integer :: n, leng

  div_r1d_y = 0.0

  if (myid == mid) then
    do n = 1, np
      d  = gpws(n)
      leng = d%nj - 2
      if ( d%id == mid ) then
        div_r1d_y(2:d%nj-1) = glo_var(d%gs:d%gn)
      else
        call mpi_ssend (glo_var(d%gs:d%gn), leng, mpi_real8, d%id, &
          tag, mpi_comm_world, err)
      end if
    end do

  else
    leng = gpw%nj - 2
    call mpi_recv (div_r1d_y(2:gpw%nj-1), leng, mpi_real8, &
      mid, tag, mpi_comm_world, msta, err)
  end if

  call swpbnd_r1d (div_r1d_y, 'y')

end function div_r1d_y

function div_r1d_x (glo_var) !{{{1
  ! distribute 1d array from mid to other domains

  real (kind=wp), dimension(glo_ni), intent(in) :: glo_var
  real (kind=wp), dimension(gpw%ni) :: div_r1d_x

  integer, parameter :: tag = 50
  type (type_gpw) :: d
  integer :: n, leng

  div_r1d_x = 0.0

  if (myid == mid) then
    do n = 1, np
      d  = gpws(n)
      leng = d%ni - 2
      if ( d%id == mid ) then
        div_r1d_x(2:d%ni-1) = glo_var(d%gw:d%ge)
      else
        call mpi_ssend (glo_var(d%gw:d%ge), leng, mpi_real8, d%id, &
          tag, mpi_comm_world, err)
      end if
    end do

  else
    leng = gpw%ni - 2
    call mpi_recv (div_r1d_x(2:gpw%ni-1), leng, mpi_real8, &
      mid, tag, mpi_comm_world, msta, err)
  end if

  call swpbnd_r1d (div_r1d_x, 'x')

end function div_r1d_x

function div_r1d_z (glo_var) !{{{1
  ! distribute 1d array from mid to other domains

  real (kind=wp), dimension(glo_nk), intent(in) :: glo_var
  real (kind=wp), dimension(gpw%nk) :: div_r1d_z

  integer, parameter :: tag = 50
  type (type_gpw) :: d
  integer :: n, leng

  div_r1d_z = 0.0

  if (myid == mid) then
    do n = 1, np
      d  = gpws(n)
      leng = d%nk - 2
      if ( d%id == mid ) then
        div_r1d_z(2:d%nk-1) = glo_var(d%gu:d%gl)
      else
        call mpi_ssend (glo_var(d%gu:d%gl), leng, mpi_real8, d%id, &
          tag, mpi_comm_world, err)
      end if
    end do

  else
    leng = gpw%nk - 2
    call mpi_recv (div_r1d_z(2:gpw%nk-1), leng, mpi_real8, &
      mid, tag, mpi_comm_world, msta, err)
  end if

  call swpbnd_r1d (div_r1d_z, 'z')

end function div_r1d_z

function div_i3d (glo_var) !{{{1
  ! distribute 3d array from mid to other domains

  integer, dimension(:,:,:), intent(in) :: glo_var

  integer, dimension(gpw%ni, gpw%nj, gpw%nk):: div_i3d

  integer, parameter :: tag = 20
  type (type_gpw) :: d
  integer :: n, leng

  div_i3d = 0.0

  if (myid == mid) then

    do n = 1, np
      d = gpws(n)
      leng = (d%ni - 2) * (d%nj - 2) * (d%nk - 2)
      if ( d%id == mid ) then
        div_i3d(2:gpw%ni-1, 2:gpw%nj-1, 2:gpw%nk-1) = &
          glo_var(d%gw:d%ge, d%gs:d%gn, d%gu:d%gl)
      else
        call mpi_ssend (glo_var(d%gw:d%ge,d%gs:d%gn,d%gu:d%gl), &
          leng, mpi_integer, d%id, tag, mpi_comm_world, err)
      end if
    end do

  else
    leng = (gpw%ni - 2) * (gpw%nj - 2) * (gpw%nk - 2)
    call mpi_recv (div_i3d(2:gpw%ni-1,2:gpw%nj-1,2:gpw%nk-1), &
      leng, mpi_integer, mid, tag, mpi_comm_world, msta, err)
  end if

  call swpbnd_i3d (div_i3d)

end function div_i3d

function div_i2d (glo_var) !{{{1
  ! distribute 2d array from mid to other domains

  integer, dimension(:,:), intent(in) :: glo_var

  integer, dimension(gpw%ni, gpw%nj) :: div_i2d

  integer, parameter :: tag = 90
  type (type_gpw) :: d
  integer :: n, leng

  div_i2d = 0

  if (myid == mid) then
    do n = 1, np
      d = gpws(n)
      leng = (d%ni - 2) * (d%nj - 2)
      if ( d%id == mid ) then
        div_i2d(2:gpw%ni-1, 2:gpw%nj-1) = glo_var(d%gw:d%ge, d%gs:d%gn)
      else
        call mpi_ssend (glo_var(d%gw:d%ge,d%gs:d%gn), &
          leng, mpi_integer, d%id, tag, mpi_comm_world, err)
      end if
    end do

  else
    leng = (gpw%ni - 2) * (gpw%nj - 2)
    call mpi_recv (div_i2d(2:gpw%ni-1,2:gpw%nj-1), leng, mpi_integer, &
      mid, tag, mpi_comm_world, msta, err)
  end if

  call swpbnd_i2d (div_i2d)

end function div_i2d

subroutine mympi_fix_integrate (var) !{{{1
  ! fix indefinite integration from sea surface to the bottom

  real (kind=wp), dimension(:) :: var

  integer, parameter :: tag  = 70
  integer, parameter :: leng = 1
  real (kind=wp) :: r

  if ( gpw % gu == 1 ) then
    call mpi_ssend (var(gpw%nk-1), leng, mpi_real8, gpw % l, &
      tag, mpi_comm_world, err)
  else
    call mpi_recv (r, leng, mpi_real8, gpw % u, &
      tag, mpi_comm_world, msta, err)

    call mpi_ssend (var(gpw%nk-1)+r, leng, mpi_real8, gpw % l, &
      tag, mpi_comm_world, err)

    var(2:gpw%nk-1) = var(2:gpw%nk-1) + r
  end if

  call swpbnd_r1d (var, 'z')

end subroutine mympi_fix_integrate

subroutine mympi_pass_baton (baton, copy) !{{{1
  ! pass a scalar from bottom id to upper ids

  real (kind=wp), intent(in) :: baton
  real (kind=wp) :: copy

  integer, parameter :: tag  = 80
  integer, parameter :: leng = 1

  if ( gpw % gl == glo_nk ) then
    call mpi_ssend (baton, leng, mpi_real8, gpw % u, &
      tag, mpi_comm_world, err)
    copy = baton
  else
    call mpi_recv (copy, leng, mpi_real8, gpw % l, &
      tag, mpi_comm_world, msta, err)

    call mpi_ssend (copy, leng, mpi_real8, gpw % u, &
      tag, mpi_comm_world, err)
  end if

end subroutine mympi_pass_baton

subroutine mympi_diffuse_z (var, tag) !{{{1
  ! diffuse var along both direction of z

  real (kind=wp), intent(in) :: var
  integer, intent(in) :: tag

  integer, parameter :: leng = 1

  call mpi_ssend (var, leng, mpi_real8, gpw % u, &
    tag, mpi_comm_world, err)

  call mpi_ssend (var, leng, mpi_real8, gpw % l, &
    tag, mpi_comm_world, err)

end subroutine mympi_diffuse_z

subroutine mympi_recvsend_up (var, tag) !{{{1
  ! receive and send along upwards direction

  real (kind=wp) :: var
  integer, intent(in) :: tag

  integer, parameter :: leng = 1

  call mpi_recv (var, leng, mpi_real8, gpw % l, &
    tag, mpi_comm_world, msta, err)

  call mpi_ssend (var, leng, mpi_real8, gpw % u, &
    tag, mpi_comm_world, err)

end subroutine mympi_recvsend_up

subroutine mympi_recvsend_down (var, tag) !{{{1
! receive and send along downwards direction

  real (kind=wp) :: var
  integer, intent(in) :: tag

  integer, parameter :: leng = 1

  call mpi_recv (var, leng, mpi_real8, gpw % u, &
    tag, mpi_comm_world, msta, err)

  call mpi_ssend (var, leng, mpi_real8, gpw % l, &
    tag, mpi_comm_world, err)

end subroutine mympi_recvsend_down

subroutine chk( ista ) !{{{1
  ! check state of allocate array 

  integer, intent(in) ::  ista

  if ( ista /= 0 ) then
    write(*,*) 'Allocate array failed. Stop'
    stop 2
  end if
end subroutine chk

end module mod_mympi !{{{1
!-------------------------------------------------------{{{1
! vim:fdm=marker:fdl=0:
! vim:foldtext=getline(v\:foldstart).'...'.(v\:foldend-v\:foldstart):
