
! Description: basic NetCDF input/output interface
!
!      Author: OU Yuyuan <ouyuyuan@lasg.iap.ac.cn>
!     Created: 2015-03-06 10:38:13 BJT
! Last Change: 2015-10-26 14:03:06 BJT

module mod_io !{{{1 
!-------------------------------------------------------{{{1
!imported variables-------------------------------------{{{1
  use netcdf
  use mod_kind, only: sp, wp

  use mod_param, only: missing_int, missing_float, &
    glo_ni, glo_nj, glo_nk, names, units, myid, gpw, &
    type_gpw, type_gpz, mid

  use mod_type, only: type_time

  use mod_pro, only: pro_allo_chk

  use mod_arrays, only: glo_lat, glo_lon, glo_z

  implicit none
  private

!public subroutines-------------------------------------{{{1

  public &
    io_create,        &
    io_get_dim_len,   &
    io_print,         &
    io_write,         &
    io_quick_output,  &
    io_read

!internal variables-------------------------------------{{{1

  integer :: ncid, varid, ndim1, ndim2, ndim3

!interfaces---------------------------------------------{{{1
!-----------------------------------------------------------
  interface io_write
    module procedure write_scalar
    module procedure write_r3d
    module procedure write_r1d
  end interface

  interface io_quick_output
    module procedure quick_output_r3d
    module procedure quick_output_r2d
    module procedure quick_output_r1d
    module procedure quick_output_i2d
  end interface

  interface io_read
    module procedure read_r3d
    module procedure read_r1d
    module procedure read_i3d
    module procedure read_i2d
    module procedure read_scalar
  end interface

  interface io_print
    module procedure print_i3d
    module procedure print_i2d
    module procedure print_r3d
    module procedure print_r2d
    module procedure print_r1d
    module procedure print_type_time
    module procedure print_type_gpw
    module procedure print_type_gpz
  end interface

contains !{{{1
!-------------------------------------------------------{{{1

subroutine io_create (ncname) !{{{1

  character (len=*), intent(in) :: ncname

  integer :: dimid1, dimid2, dimid3, dimid4, i
  integer :: dimids(4)

  call check ( nf90_create (ncname, NF90_CLOBBER, ncid)  )

  !def dim. {{{1
  call check ( nf90_def_dim (ncid, 'lon', glo_ni, dimid1) )
  call check ( nf90_def_dim (ncid, 'lat', glo_nj, dimid2) )
  call check ( nf90_def_dim (ncid, 'z',   glo_nk, dimid3) )
  call check ( nf90_def_dim (ncid, 't', NF90_UNLIMITED, dimid4) )

  !def global attr. {{{1
  call check ( nf90_put_att (ncid, NF90_GLOBAL, & 
    'created', "by subroutine io_create in module mod_io") )

  ! def vars  !{{{1
  call check ( nf90_def_var (ncid, "lon", nf90_float, &
    dimid1, varid) )
  call check ( nf90_put_att (ncid, varid, 'units', &
    'degree_east') )

  call check ( nf90_def_var (ncid, "lat", nf90_float, &
    dimid2, varid) )
  call check ( nf90_put_att (ncid, varid, 'units', &
    'degree_north') )

  call check ( nf90_def_var (ncid, "z", nf90_float, &
    dimid3, varid) )
  call check ( nf90_put_att (ncid, varid, 'units', &
    'm') )

  dimids = (/dimid1, dimid2, dimid3, dimid4/)

  call check ( nf90_def_var (ncid, names % pt, nf90_float, &
    dimids, varid) )
  call check ( nf90_put_att (ncid, varid, '_FillValue', &
    missing_float) )
  call check ( nf90_put_att (ncid, varid, 'units', &
    units % pt) )

  call check ( nf90_def_var (ncid, names % sa, nf90_float, &
    dimids, varid) )
  call check ( nf90_put_att (ncid, varid, '_FillValue', &
    missing_float) )
  call check ( nf90_put_att (ncid, varid, 'units', &
    units % sa) )

  !end def {{{1
  call check (nf90_enddef(ncid) )

  call check (nf90_close(ncid) )

end subroutine io_create

subroutine write_r3d(ncname, varname, var, nrec) !{{{1

  character (len = *), intent(in) :: ncname, varname
  real (kind=wp), intent(in) :: var(:,:,:)

  integer :: stt(4), cnt(4), nrec

  write(*,'(a,i3,a)') '*** Output '//varname//' to file: '//ncname//' for the ', &
    nrec, 'th record ~ ~ ~' 

  ndim1 = size(var, 1)
  ndim2 = size(var, 2)
  ndim3 = size(var, 3)

  stt  = (/1, 1, 1, nrec/)
  cnt  = (/ndim1, ndim2, ndim3, 1/)

  call check (nf90_open(ncname, nf90_write, ncid)  )

  call check (nf90_inq_varid(ncid, varname, varid) )

  call check (nf90_put_var(ncid, varid, var, &
    start = stt, count = cnt) )

  call check (nf90_close(ncid) )

end subroutine write_r3d

subroutine write_r1d(ncname, varname, var) !{{{1

  character (len = *), intent(in) :: ncname, varname
  real (kind=wp), intent(in) :: var(:)

  integer :: is

  call check (nf90_open(ncname, nf90_write, ncid)  )

  call check (nf90_inq_varid(ncid, varname, varid) )

  call check (nf90_put_var(ncid, varid, var) )

  call check (nf90_close(ncid) )

  write(*,*) '*** SUCCESS output '//varname//' to file: '//ncname

end subroutine write_r1d

subroutine write_scalar(ncname, varname, var) !{{{1

  character (len = *), intent(in) :: ncname, varname
  real (kind=wp), intent(in) :: var

  call check (nf90_open(ncname, nf90_write, ncid)  )

  call check (nf90_inq_varid(ncid, varname, varid) )

  call check (nf90_put_var(ncid, varid, var) )

  call check (nf90_close(ncid) )

  write(*,*) '*** SUCCESS output '//varname//' to file: '//ncname

end subroutine write_scalar

subroutine quick_output_r3d ( ncname, varname, var ) !{{{1
  ! creat a new file and output a 3d real variable

  character (len = *), intent(in) :: ncname, varname
  real (kind=wp),      intent(in) :: var(:,:,:)

  integer :: dimids(4)
  integer :: nrec, stt(4), cnt(4), &
             dimid1, dimid2, dimid3, time_dimid, &
             lonid, latid, zid

  ndim1 = size(var, 1)
  ndim2 = size(var, 2)
  ndim3 = size(var, 3)

  nrec = 1
  stt  = (/1, 1, 1, nrec/)
  cnt  = (/ndim1, ndim2, ndim3, 1/)

  call check (nf90_create(ncname, NF90_CLOBBER, ncid)  )

  ! def dim. {{{2
  call check (nf90_def_dim(ncid, 'lon', ndim1, dimid1) )
  call check (nf90_def_dim(ncid, 'lat', ndim2, dimid2) )
  call check (nf90_def_dim(ncid, 'z',   ndim3, dimid3) )
  call check (nf90_def_dim(ncid, 'time', NF90_UNLIMITED, &
    time_dimid) )

  ! def vars !{{{2
  call check (nf90_def_var(ncid, 'lon', nf90_float, dimid1, lonid) )
  call check (nf90_def_var(ncid, 'lat', nf90_float, dimid2, latid) )
  call check (nf90_def_var(ncid, 'z',   nf90_float, dimid3, zid) )

  dimids =  (/ dimid1, dimid2, dimid3, time_dimid /)
  call check (nf90_def_var(ncid, varname, nf90_float, dimids, &
    varid) )
  call check (nf90_put_att(ncid, varid, '_FillValue', &
    missing_float) )

  call check (nf90_enddef(ncid) )

  ! write vars !{{{2
  call check (nf90_put_var(ncid, lonid, glo_lon))
  call check (nf90_put_var(ncid, latid, glo_lat))
  call check (nf90_put_var(ncid, zid, glo_z))

  call check (nf90_put_var(ncid, varid, var, &
    start = stt, count = cnt) )

  ! close file !{{{2
  call check (nf90_close(ncid) )

  write(*,*) '*** SUCCESS output '//varname//' to file: '//ncname

end subroutine quick_output_r3d

subroutine quick_output_r2d ( ncname, varname, var ) !{{{1
  ! creat a new file and output a 2d real variable

  character (len = *), intent(in) :: ncname, varname
  real (kind=wp),      intent(in) :: var(:,:)

  integer :: dimids(3)
  integer :: nrec, stt(3), cnt(3), &
             dimid1, dimid2, time_dimid, &
             lonid, latid

  ndim1 = size(var, 1)
  ndim2 = size(var, 2)

  nrec = 1
  stt  = (/1, 1, nrec/)
  cnt  = (/ndim1, ndim2, 1/)

  call check (nf90_create(ncname, NF90_CLOBBER, ncid)  )

  ! def dim. {{{2
  call check (nf90_def_dim(ncid, 'lon', ndim1, dimid1) )
  call check (nf90_def_dim(ncid, 'lat', ndim2, dimid2) )
  call check (nf90_def_dim(ncid, 'time', NF90_UNLIMITED, &
    time_dimid) )

  ! def vars !{{{2
  dimids =  (/ dimid1, dimid2, time_dimid /)
  call check (nf90_def_var(ncid, 'lon', nf90_float, dimid1, lonid) )
  call check (nf90_def_var(ncid, 'lat', nf90_float, dimid2, latid) )

  call check (nf90_def_var(ncid, varname, nf90_float, dimids, &
    varid) )
  call check (nf90_put_att(ncid, varid, '_FillValue', &
    missing_float) )

  call check (nf90_enddef(ncid) )

  ! write var !{{{2
  call check (nf90_put_var(ncid, lonid, glo_lon))
  call check (nf90_put_var(ncid, latid, glo_lat))

  call check (nf90_put_var(ncid, varid, var, &
    start = stt, count = cnt) )

  ! close file !{{{2
  call check (nf90_close(ncid) )

  write(*,*) '*** SUCCESS output '//varname//' to file: '//ncname

end subroutine quick_output_r2d

subroutine quick_output_r1d ( ncname, varname, var, c ) !{{{1
  ! creat a new file and output a 1d real variable

  character (len = *), intent(in) :: ncname, varname
  character (len = 1), intent(in) :: c
  real (kind=wp),      intent(in) :: var(:)

  integer :: dimid1, time_dimid, stt(2), cnt(2), &
    latid, lonid, zid, dimids(2), nrec

  ndim1 = size(var)

  nrec = 1
  stt  = (/1, nrec/)
  cnt  = (/ndim1, 1/)

  call check (nf90_create(ncname, NF90_CLOBBER, ncid)  )

  ! def dim. {{{2
  if (c.eq.'y') then
    call check (nf90_def_dim(ncid, 'lat', ndim1, dimid1) )
    call check (nf90_def_var(ncid, 'lat', nf90_float, dimid1, latid) )
  else if (c.eq.'x') then
    call check (nf90_def_dim(ncid, 'lon', ndim1, dimid1) )
    call check (nf90_def_var(ncid, 'lon', nf90_float, dimid1, lonid) )
  else if (c.eq.'z') then
    call check (nf90_def_dim(ncid, 'z',   ndim1, dimid1) )
    call check (nf90_def_var(ncid, 'z',   nf90_float, dimid1, zid) )
  else
    stop 'unhandled character in quick_output_r1d'
  end if

  call check (nf90_def_dim(ncid, 'time', NF90_UNLIMITED, &
    time_dimid) )

  ! def var !{{{2
  dimids =  (/ dimid1, time_dimid /)
  call check (nf90_def_var(ncid, varname, nf90_float, dimids, &
    varid) )
  call check (nf90_put_att(ncid, varid, '_FillValue', &
    missing_float) )

  call check (nf90_enddef(ncid) )

  ! write vars !{{{2
  if (c.eq.'y') then
    call check (nf90_put_var(ncid, latid, glo_lat))
  else if (c.eq.'x') then
    call check (nf90_put_var(ncid, lonid, glo_lon))
  else if (c.eq.'z') then
    call check (nf90_put_var(ncid, zid, glo_z))
  end if

  call check (nf90_put_var(ncid, varid, var, &
    start = stt, count = cnt) )

  ! close file !{{{2
  call check (nf90_close(ncid) )

  write(*,*) '*** SUCCESS output '//varname//' to file: '//ncname

end subroutine quick_output_r1d

subroutine quick_output_i2d ( ncname, varname, var ) !{{{1
  ! creat a new file and output a 2d real variable

  character (len = *), intent(in) :: ncname, varname
  integer, intent(in) :: var(:,:)

  integer :: dimid1, dimid2, lonid, latid

  ndim1 = size(var, 1)
  ndim2 = size(var, 2)

  call check (nf90_create(ncname, NF90_CLOBBER, ncid)  )

  ! def dim. {{{2
  call check (nf90_def_dim(ncid, 'lon', ndim1, dimid2) )
  call check (nf90_def_dim(ncid, 'lat', ndim2, dimid1) )

  ! def vars !{{{2
  call check (nf90_def_var(ncid, 'lon', nf90_float, dimid1, lonid) )
  call check (nf90_def_var(ncid, 'lat', nf90_float, dimid2, latid) )

  call check (nf90_def_var(ncid, varname, nf90_int, &
    (/dimid1, dimid2/), varid) )
  call check (nf90_put_att(ncid, varid, '_FillValue', &
    missing_int) )

  call check (nf90_enddef(ncid) )

  ! write var !{{{2
  call check (nf90_put_var(ncid, latid, glo_lat))
  call check (nf90_put_var(ncid, lonid, glo_lon))

  ! quit odd, it will print the first four elements in the first row 
  ! of var to the screen when execute at BCM, maybe this is a bug of netcdf
  call check (nf90_put_var(ncid, varid, var))

  ! close file !{{{2
  call check (nf90_close(ncid) )

  write(*,*) '*** SUCCESS output '//varname//' to file: '//ncname

end subroutine quick_output_i2d

subroutine read_r3d(ncname, varname, var) !{{{1
  character (len=*), intent(in) :: ncname, varname
  real (kind=wp) :: var(:,:,:)

  call check (nf90_open(ncname, NF90_NOWRITE, ncid) )

  call check (nf90_inq_varid(ncid, varname, varid) )

  call check (nf90_get_var(ncid, varid, var) )

  call check (nf90_close(ncid) )

  write(*,'(a)') 'got '//trim(varname)// ' from '//trim(ncname)

end subroutine read_r3d 

subroutine read_r1d(ncname, varname, var) !{{{1
  character (len=*), intent(in) :: ncname, varname
  real (kind=wp) :: var(:)

  call check (nf90_open(ncname, NF90_NOWRITE, ncid) )

  call check (nf90_inq_varid(ncid, varname, varid) )

  call check (nf90_get_var(ncid, varid, var) )

  call check (nf90_close(ncid) )

  write(*,'(a)') 'got '//trim(varname)// ' from '//trim(ncname)
end subroutine read_r1d 

subroutine read_i3d(ncname, varname, var) !{{{1
  character (len=*), intent(in) :: ncname, varname
  integer :: var(:,:,:)

  call check (nf90_open(ncname, NF90_NOWRITE, ncid) )

  call check (nf90_inq_varid(ncid, varname, varid) )

  call check (nf90_get_var(ncid, varid, var) )

  call check (nf90_close(ncid) )

  write(*,'(a)') 'got '//trim(varname)// ' from '//trim(ncname)

end subroutine read_i3d 

subroutine read_i2d(ncname, varname, var) !{{{1
  character (len=*), intent(in) :: ncname, varname
  integer :: var(:,:)

  call check (nf90_open(ncname, NF90_NOWRITE, ncid) )

  call check (nf90_inq_varid(ncid, varname, varid) )

  call check (nf90_get_var(ncid, varid, var) )

  call check (nf90_close(ncid) )

  write(*,'(a)') 'got '//trim(varname)// ' from '//trim(ncname)

end subroutine read_i2d 

subroutine read_scalar(ncname, varname, var) !{{{1
  character (len=*), intent(in) :: ncname, varname
  real (kind=wp) :: var

  call check (nf90_open(ncname, NF90_NOWRITE, ncid) )

  call check (nf90_inq_varid(ncid, varname, varid) )

  call check (nf90_get_var(ncid, varid, var) )

  call check (nf90_close(ncid) )
end subroutine read_scalar

subroutine print_type_time(var) !{{{1
  ! print self defined type of type_time
  
  type (type_time) :: var

  ! print as the form of yyyy-mm-dd hh:mm:ss
  write(*,'(i0.4,a,i0.2,a,i0.2,x,i0.2,a,i0.2,a,i0.2)') &
    var % y, '-', var % m,  '-', var % d, &
    var % h, ':', var % mi, ':', var % s
  
end subroutine print_type_time

subroutine print_type_gpw (gp) !{{{1
  ! print gp define in mod_param
  type (type_gpw) :: gp
  
  write(*,'(2(a,i12), 4(a,i3), 12(a, i3))') 'comm =', gp%c, ', group = ', gp%g, &
    ', id = ', gp%id, ', i = ', gp%i, ', j = ', gp%j, ', k = ', gp%k, &
    ', west = ', gp%w, ', east = ', gp%e, &
    ', north = ', gp%n, ', south = ', gp%s, &
    ', upper = ', gp%u, ', lower = ', gp%l, &
    ', gn = ', gp%gn, ', gs = ', gp%gs, &
    ', gw = ', gp%gw, ', ge = ', gp%ge, &
    ', gu = ', gp%gu, ', gl = ', gp%gl
  
end subroutine print_type_gpw

subroutine print_type_gpz (gp) !{{{1
  ! print gp define in mod_param
  type (type_gpz) :: gp
  
  write(*,'(2(a,i12), 2(a,i3), 4(a, i3))') 'comm =', gp%c, ', group = ', gp%g, &
    ', id = ', gp%id,  ', k = ', gp%k, &
    ', upper = ', gp%u, ', lower = ', gp%l, &
    ', gu = ', gp%gu, ', gl = ', gp%gl
  
end subroutine print_type_gpz

subroutine print_r3d (var) !{{{1
! print 3d reall array in a nice way
  
  real (kind=wp) :: var(:,:,:)
  integer :: ni, nj, nk, i, j, k

  ni = size(var, 1)
  nj = size(var, 2)
  nk = size(var, 3)

  do k = 1, nk
    do i = 1, ni
      write(*,'(a, i2, 100f5.1)') 'myid = ', myid, var(i,:,k)
    end do
    write(*,*) ''
  end do
  
end subroutine print_r3d

subroutine print_r2d (var, opt) !{{{1
! print 2d array in a nice way
  
  real (kind=wp) :: var(:,:)
  character (len=*), optional :: opt ! print boundary 

  integer :: ni, nj, i, j

  ni = size(var, 1)
  nj = size(var, 2)

  if ( present(opt) )then

    ! print east west boundary
    if ( opt .eq. 'ew' ) then
      do i = 2, ni - 1
        write(*,'(a, i2, 2e7.1e1, a, 2e7.1e1)') 'myid = ', myid, &
          var(i,1), var(i,2), ' . . . ', var(i,nj-1), var(i,nj)
      end do
    ! print north south
    else if ( opt .eq. 'ns' ) then
      write(*,'(2(a,i2), a, 100e7.1e1)') 'myid = ', myid, &
        ', row = ', 1, ', ', var(1,2:nj-1)
      write(*,'(2(a,i2), a, 100e7.1e1)') 'myid = ', myid, &
      ', row = ', 2, ', ', var(2,2:nj-1)
      write(*,'(a)') ' . . . . . . '
      write(*,'(2(a,i2), a, 100e7.1e1)') 'myid = ', myid, &
      ', row = ', ni - 1, ', ', var(ni-1,2:nj-1)
      write(*,'(2(a,i2), a, 100e7.1e1)') 'myid = ', myid, &
      ', row = ', ni, ', ', var(ni,2:nj-1)
      write(*,*) ''
    else
      write(*,*) 'unknow option '//opt//' in routine print_r2d in module mod_io'
      stop
    end if

  else

    do i = 1, ni
      write(*,'(a, i2, 100e7.1e1)') 'myid = ', myid, var(i,:)
    end do

  end if
  
end subroutine print_r2d

subroutine print_r1d (var) !{{{1
! print 2d integer array in a nice way
  
  real (kind=wp) :: var(:)

  write(*,'(a, i2, 100i5)') 'myid = ', myid, int(var(:))

end subroutine print_r1d

subroutine print_i3d (var) !{{{1
! print 2d integer array in a nice way
  
  integer :: var(:,:,:)
  integer :: ni, nj, nk, i, j, k

  ni = size(var, 1)
  nj = size(var, 2)
  nk = size(var, 3)

  do k = 1, nk
    do i = 1, ni
      write(*,"(100i3)") var(i,:,k)
    end do

    write (*,*) ''
  end do
  
end subroutine print_i3d

subroutine print_i2d (var, opt) !{{{1
! print 2d array in a nice way
  
  integer :: var(:,:)
  character (len=*), optional :: opt ! print boundary 

  integer :: ni, nj, i, j

  ni = size(var, 1)
  nj = size(var, 2)

  if ( present(opt) )then

    ! print east west boundary
    if ( opt .eq. 'ew' ) then
      do i = 2, ni - 1
        write(*,'(a, i2, 2i3, a, 2i3)') 'myid = ', myid, &
          var(i,1), var(i,2), ' . . . ', var(i,nj-1), var(i,nj)
      end do
    ! print north south
    else if ( opt .eq. 'ns' ) then
      write(*,'(2(a,i2), a, 100i3)') 'myid = ', myid, &
        ', row = ', 1, ', ', var(1,2:nj-1)
      write(*,'(2(a,i2), a, 100i3)') 'myid = ', myid, &
      ', row = ', 2, ', ', var(2,2:nj-1)
      write(*,'(a)') ' . . . . . . '
      write(*,'(2(a,i2), a, 100i3)') 'myid = ', myid, &
      ', row = ', ni - 1, ', ', var(ni-1,2:nj-1)
      write(*,'(2(a,i2), a, 100i3)') 'myid = ', myid, &
      ', row = ', ni, ', ', var(ni,2:nj-1)
      write(*,*) ''
    else
      write(*,*) 'unknow option '//opt//' in routine print_i2d in module mod_io'
      stop
    end if

  else

    do i = 1, ni
      write(*,'(a, i2, 100i3)') 'myid = ', myid, int(var(i,:))
    end do

  end if
  
end subroutine print_i2d


subroutine io_get_dim_len(ncname, dimname, var) !{{{1
! get the length of a dimension with 'dimname' from a 
! NetCDF file with 'ncname'
  character (len = *), intent(in) :: ncname, dimname
  integer, intent(out) :: var
  integer :: dimid

  call check ( nf90_open(ncname, NF90_NOWRITE, ncid) )

  call check ( nf90_inq_dimid(ncid, dimname, dimid) )

  call check ( nf90_inquire_dimension(ncid, dimid, len = var) )

  call check ( nf90_close(ncid) )

end subroutine io_get_dim_len

subroutine check(status) !{{{1
!-----------------------------------------------------------
! check netcdf call
!-----------------------------------------------------------
  integer, intent (in) :: status

  if(status /= nf90_noerr) then 
    print *, trim(nf90_strerror(status))
    stop
  end if
end subroutine check  

end module mod_io !{{{1
!-------------------------------------------------------{{{1
! vim:fdm=marker:fdl=0:
! vim:foldtext=getline(v\:foldstart).'...'.(v\:foldend-v\:foldstart):
