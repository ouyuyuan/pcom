
! Description: 
!
!      Author: OU Yuyuan <ouyuyuan@lasg.iap.ac.cn>
!     Created: 2015-09-13 08:14:52 BJT
! Last Change: 2015-10-29 20:13:43 BJT

program main

  ! imported variables !{{{1
  !-------------------------------------------------------=-
  use mpi
  use mod_kind, only: wp

  use mod_type, only: &
    type_time, type_str2time, &
    type_str2sec, type_accu_r3d, type_vector, &
    operator (+), operator (<), operator (*), &
    assignment (=)

  use mod_param, only: &
    nm, gpw, gpz, &
    glo_ni, glo_nj, glo_nk, &
    ni, nj, nk, nim, njm, nkm, &
    myid, np, mid, names, ids

  use mod_io, only: io_create, &
    io_get_dim_len, io_write, &
    io_print, io_quick_output

  use mod_mympi, only: &
    mympi_div, mympi_output, mympi_swpbnd, &
    mympi_allreduce_z, mympi_bcast_s2z, &
    mympi_bcast

  use mod_arrays, only: phu, ph, iun, itn, &
    gvu, gvw, &
    mg1, mg3, mg4, mg2, &
    glo_lon, glo_lat, glo_z, &
    s, ub, pubt, &
    am, ams
    
  use mod_op, only: &
    op_ter, op_div

  use mod_master, only: &
    master_initialize, master_write_dim_info, &
    glo_ph, glo_pt, glo_sa, glo_itn 

  ! local variables !{{{1
  implicit none

  integer, parameter :: fid_dia = 10

  type :: time_ctrl
    type (type_time) :: pt, ct ! time of the previous/current barotropic step
    real (kind=wp)   :: t1, t2 ! mpi time barrier, for time consuming calc.
    integer*8        :: nt     ! total baroclinic time steps
  end type
  type (time_ctrl) :: time

  ! accumulated variables, for time-average output
  type (type_accu_r3d) :: ac_pt, ac_sa

  real (kind=wp), allocatable, dimension(:,:,:) :: &
    pt, sa 
  real (kind=wp), allocatable, dimension(:) :: &
    lon, lat, z

  integer, allocatable, dimension(:,:,:) :: &
    umsk, tmsk
  integer :: err, leng, errorcode, i

  character (len=mpi_max_processor_name) :: hostname

  ! MPI environment !{{{1
  !---------------------------------------------------------
  call mpi_init (err)
  if (err .ne. mpi_success) then 
    write(*,*) 'Error starting MPI program. Terminating. :-('
    call mpi_abort (mpi_comm_world, errorcode, err)
  end if

  call mpi_comm_rank (mpi_comm_world, myid, err)
  call mpi_comm_size (mpi_comm_world, np, err)
  call mpi_get_processor_name (hostname, leng, err)
  write(*,'(a, i4, a, i4, a, a)') 'Number of tasks = ', np, &
    ', My rank = ', myid, ', running on '//trim(hostname)//' :-)'

  ! preparation !{{{1
  if ( myid == mid ) open( fid_dia, file='diaginfo.txt' )

  call initialize ()

  ! create output file
  if ( myid == mid ) then
    call io_create (nm%fo)
    write(fid_dia, '(a)') 'created output file '//nm%fo

    call io_write (trim(nm%fo), 'lon', glo_lon)
    call io_write (trim(nm%fo), 'lat', glo_lat)
    call io_write (trim(nm%fo), 'z',   glo_z)
  end if

  ! integration cycle !{{{1

  ! time prepare !{{{2
  time%ct = type_str2time (nm%bd)
  time%pt = time%ct
  time%nt = ( type_str2sec(nm%ed) - type_str2sec(nm%bd) ) / nm%bc

  ! baroclinic integrate !{{{2

  time%t1 = mpi_wtime () ! time count start

  do i = 1, time%nt
    ! integrate series time steps per baroclinic time step
    call barotropic ()

    ! accumulate ouput fields for time-average output
    ac_pt % p = ac_pt % p + pt
    ac_pt % n = ac_pt % n + 1

    ac_sa % p = ac_sa % p + sa
    ac_sa % n = ac_sa % n + 1

    ! need ouput integrated results or not
    call output_check ()
  end do

  call test ()

  ! finish integration !{{{1
  if (myid == mid) then
    write (*, *) ''
    write (*, '(a)') 'Done model run.'
    write (*, '(a, i9, a)') &
      'Integrated for ', time%nt, ' baroclinic time steps.'
  end if

  call mpi_finalize (err)

contains  !{{{1

subroutine test () !{{{1
  use mod_mympi, only: mympi_quick_output
 
!  call mympi_quick_output ('itn.nc', 'itn', itn)
!  call mympi_quick_output ('iun.nc', 'iun', iun)
!  call mympi_quick_output ('phu.nc', 'phu', phu)

!call io_print (gpz)

end subroutine test

subroutine output_check () !{{{1

  ! the integration enters a new day
  if ( time%ct%d /= time%pt%d ) then
    time%t2 = mpi_wtime ()
    write(*, '(a, i0.4,a,i0.2,a,i0.2, a, f5.2, a, i3)') &
      'integrate for ', time%pt%y, '-', time%pt%m, '-', time%pt%d, &
      ' use ', time%t2 - time%t1, ' seconds on processor ', myid 
    time%t1 = time%t2

    if ( nm%per .eq. 'day')  then
      call output ()
    end if

    ! the integration enters a new month
    if ( (time%ct%m /= time%pt%m) .and. (nm%per .eq. 'month') ) then
      call output ()
    end if

    ! the integration enters a new year
    if ( (time%ct%y /= time%pt%y) .and. (nm%per .eq. 'year') ) then
      call output ()
    end if
  end if

end subroutine output_check

subroutine output () !{{{1
  call mympi_output (nm%fo, names % pt, ac_pt)
  call mympi_output (nm%fo, names % sa, ac_sa)
end subroutine output

subroutine barotropic () !{{{1
  ! barotropic integrations for 2 baroclinic steps
  use mod_con, only: gamma_b
  use mod_op, only: op_lap

  type (type_vector), dimension(ni,nj) :: &
    sub, & ! scale barotropic velocity
    vsu ! horizontal viscosity

  real (kind=wp), dimension(ni,nj) :: &
    pst, & ! partial s/partial t, g1-grid
    ss     ! g3-grid

  integer :: i

  ! use surface layer viscosity in barotropic momentum equation
  ams(:,:) = am(:,:,1)
  call mympi_bcast_s2z (ams)

  do i = 1, nm%bc / nm%bt * 2
    time%pt = time%ct
    time%ct = time%ct + nm%bt

    ss = sqrt( op_ter(s % p, '1->3') )
    call mympi_swpbnd (ss)

    sub = (ph*ss) * ub

    pst(:,:) = - op_div ( sub ) / phu
    call mympi_swpbnd (pst)

    s % c = s % p + pst(:,:) * nm%bt * gamma_b
    call mympi_swpbnd (s % c)

    ss = sqrt( op_ter(s % c, '1->3') )
    call mympi_swpbnd (ss)

!    vsu = ams * op_lap( ub )

!    if ( i == 1 ) then
!      pubt(:,:) = pubt(:,:) - vsu(:,:)
!    end if
  end do

end subroutine barotropic

subroutine initialize () !{{{1
  ! initialize model environment
  use mod_param, only: param_set_groups

  ! I/O and global calculation in master id
  call master_initialize ()

  ! get namelist !{{{2

  ! distribute namelist parameters from mid to other ids
  call mympi_bcast (nm % py, nm % px, nm % pz)

  call mpi_bcast(nm % bd,  nm % ed)

  call mpi_bcast(nm % bt,  nm % bc)

  call mpi_bcast(nm % fi,  nm % fo)

  call mpi_bcast(nm % per)

  ! determine dimensions !{{{2

  call mpi_bcast(glo_nj, 1, mpi_int, mid, mpi_comm_world, err)
  call mpi_bcast(glo_ni, 1, mpi_int, mid, mpi_comm_world, err)
  call mpi_bcast(glo_nk, 1, mpi_int, mid, mpi_comm_world, err)

  ! set up mpi groups for communication
  call param_set_groups ()
  call mpi_barrier ( mpi_comm_world, err )

  ni = gpw % ni
  nj = gpw % nj
  nk = gpw % nk

  ! too many cpus are not allowed
  if ( ni <=2 ) stop 'cpu number in x direction exceeds grid points.'
  if ( nj <=2 ) stop 'cpu number in y direction exceeds grid points.'
  if ( nk <=2 ) stop 'cpu number in z direction exceeds grid points.'

  nim = ni - 1
  njm = nj - 1
  nkm = nk - 1

  call master_write_dim_info (fid_dia)

  call allocate_arrays ()

  ! get variables !{{{2

  ! from master
  lat = mympi_div (glo_lat, 'y')
  if ( gpw%gs == 1 ) lat(1) = 2*lat(2) - lat(3)
  if ( gpw%gn == glo_nj) lat(nj) = 2*lat(njm) - lat(nj-2)

  lon = mympi_div (glo_lon, 'x')
  z   = mympi_div (glo_z,   'z')

  pt  = mympi_div (glo_pt)
  sa  = mympi_div (glo_sa)
  ph  = mympi_div (glo_ph)
  itn = mympi_div (glo_itn)

  ! calc. individually

  call calc_metric (mg1, mg3, mg2, mg4) 

  call calc_vgrid (gvu, gvw)

  call calc_mask (itn, tmsk, umsk, iun)

  call calc_pbu (phu)

end subroutine initialize

subroutine allocate_arrays () !{{{1
  use mod_con, only: am_c
  ! allocate arrays for this program main
  integer :: is

  allocate(ac_pt % p(ni,nj,nk), stat=is); call chk(is)
  ac_pt % p = 0.0; ac_pt % n = 0; ac_pt % nrec = 0
  allocate(ac_sa % p(ni,nj,nk), stat=is); call chk(is)
  ac_sa % p = 0.0; ac_sa % n = 0; ac_sa % nrec = 0

  allocate(mg1  (ni,nj), stat=is); call chk(is)
  allocate(mg3  (ni,nj), stat=is); call chk(is)
  allocate(mg2(ni,nj), stat=is); call chk(is)
  allocate(mg4(ni,nj), stat=is); call chk(is)

  allocate(am(ni,nj,nk), stat=is); call chk(is); am = am_c

  allocate(pt(ni,nj,nk), stat=is); call chk(is); pt = 0.0
  allocate(sa(ni,nj,nk), stat=is); call chk(is); sa = 0.0

  allocate(umsk(ni,nj,nk), stat=is); call chk(is); umsk = 0
  allocate(tmsk(ni,nj,nk), stat=is); call chk(is); tmsk = 0

  allocate(s(ni,nj), stat=is); call chk(is)
  s%p = 1.0; s%c = 1.0

  allocate(ub (ni,nj), stat=is); call chk(is); ub = 0.0
  allocate(pubt(ni,nj), stat=is); call chk(is); pubt = 0.0

  allocate(ph(ni,nj), stat=is); call chk(is); ph = 0.0
  allocate(phu(ni,nj), stat=is); call chk(is); phu = 0.0
  allocate(ams(ni,nj), stat=is); call chk(is); ams = 0.0

  allocate(itn(ni,nj), stat=is); call chk(is); itn = 0
  allocate(iun(ni,nj), stat=is); call chk(is); iun = 0

  allocate(lat(nj), stat=is); call chk(is); lat = 0.0
  allocate(lon(ni), stat=is); call chk(is); lon = 0.0
  allocate(z  (nk), stat=is); call chk(is); z   = 0.0

  allocate(gvw(nk),stat=is); call chk(is)
  allocate(gvu(nk),stat=is); call chk(is)
end subroutine allocate_arrays

subroutine calc_mask (itn, tm, um, iun) !{{{1
  ! given levels in g1-grid of itn, calc. mask of 
  !   g1-grid tm and g3-grid um, and levels of g3-grid iun
  integer, intent(in) :: itn(nj, nj)
  integer, dimension(ni, nj, nk) :: tm, um
  integer, dimension(ni, nj) :: iun

  integer :: i, j, k, gk

  ! set to land first
  tm(:,:,:) = 0 
  um(:,:,:) = 0
  iun(:,:)  = 0

  ! the calc. of tm don't evolve interpolate from 
  !   boundary data, that's why no swap boundary is need
  !   after sub domain tm is calculated, since the boundary 
  !   is already correct
  do k = 1, nk
  do j = 1, nj
  do i = 1, ni
    gk = gpw % gu + k - 2 ! global vertical index
    if ( itn(i,j) >= gk ) tm(i,j,k) = 1
  end do
  end do
  end do

  um(:,:,:) = op_ter ( tm, '1->3' )
  call mympi_swpbnd ( um )

  ! sum up all the levels in the same vertical group to get iun
  call mympi_allreduce_z (sum(um(:,:,2:nkm), 3), iun)

end subroutine calc_mask

subroutine calc_metric (mg1, mg3, mg2, mg4) !{{{1
  ! calc. horizontal metric propertics
  use mod_con, only: a
  use mod_arrays, only: type_metric

  type (type_metric), dimension(ni,nj) :: mg1, mg3, mg2, mg4

  integer :: i, j
  real (kind=wp) :: dlon, dlat, clat

  ! inner area !{{{2
  do i = 2, nim
  do j = 2, njm
    dlon = ( lon(i+1) - lon(i-1) )*0.5
    if ( dlon < 0 ) dlon = dlon + 360 !westest/eastest longitude
    mg1(i,j) % dx1 = dlon * torad
    mg4(i,j) % dx1 = mg1(i,j) % dx1

    dlon = lon(i+1) - lon(i)
    if ( dlon < 0 ) dlon = dlon + 360
    mg2(i,j) % dx1 = dlon * torad
    mg3(i,j) % dx1 = mg2 % dx1

    dlat = lat(j) - lat(j-1)
    mg1(i,j) % dx2 = dlat * torad
    mg2(i,j) % dx2 = mg1(i,j) % dx2

    dlat = 0.5 * ( lat(j+1) - lat(j-1) )
    mg3(i,j) % dx2 = dlat * torad
    mg4(i,j) % dx2 = mg3(i,j) % dx2

    clat = 0.5 * ( lat(j) + lat(j-1) )
    mg1(i,j) % h1 = a * cos( clat*torad )
    mg2(i,j) % h1 = mg1(i,j) % h1

    clat = lat(i)
    mg3(i,j) % h1 = a * cos( clat*torad )
    mg4(i,j) % h1 = mg3(i,j) % h1
  end do
  end do

  ! swap bnd !{{{2
  call mympi_swpbnd (mg1%dx1)
  call mympi_swpbnd (mg2%dx1)
  call mympi_swpbnd (mg3%dx1)
  call mympi_swpbnd (mg4%dx1)

  call mympi_swpbnd (mg1%dx2)
  call mympi_swpbnd (mg2%dx2)
  call mympi_swpbnd (mg3%dx2)
  call mympi_swpbnd (mg4%dx2)

  call mympi_swpbnd (mg1%h1)
  call mympi_swpbnd (mg2%h1)
  call mympi_swpbnd (mg3%h1)
  call mympi_swpbnd (mg4%h1)

  ! extropolate  !{{{2
  ! extraperlate the southest latitude
  if (gpw%gs == 1) then
    mg1(:,1) % dx1 = 2 * mg1(:,2)%dx1 - mg1(:,3)%dx1
    mg2(:,1) % dx1 = 2 * mg2(:,2)%dx1 - mg2(:,3)%dx1
    mg3(:,1) % dx1 = 2 * mg3(:,2)%dx1 - mg3(:,3)%dx1
    mg4(:,1) % dx1 = 2 * mg4(:,2)%dx1 - mg4(:,3)%dx1

    mg1(:,1) % dx2 = 2 * mg1(:,2)%dx2 - mg1(:,3)%dx2
    mg2(:,1) % dx2 = 2 * mg2(:,2)%dx2 - mg2(:,3)%dx2
    mg3(:,1) % dx2 = 2 * mg3(:,2)%dx2 - mg3(:,3)%dx2
    mg4(:,1) % dx2 = 2 * mg4(:,2)%dx2 - mg4(:,3)%dx2

    mg1(:,1) % h1 = 2 * mg1(:,2)%h1 - mg1(:,3)%h1
    mg2(:,1) % h1 = 2 * mg2(:,2)%h1 - mg2(:,3)%h1
    mg3(:,1) % h1 = 2 * mg3(:,2)%h1 - mg3(:,3)%h1
    mg4(:,1) % h1 = 2 * mg4(:,2)%h1 - mg4(:,3)%h1
  end if

  ! extraperlate the northest latitude
  if (gpw%gn == glo_nj) then
    mg1(:,nj) % dx1 = 2 * mg1(:,njm)%dx1 - mg1(:,nj-2)%dx1
    mg2(:,nj) % dx1 = 2 * mg2(:,njm)%dx1 - mg2(:,nj-2)%dx1
    mg3(:,nj) % dx1 = 2 * mg3(:,njm)%dx1 - mg3(:,nj-2)%dx1
    mg4(:,nj) % dx1 = 2 * mg4(:,njm)%dx1 - mg4(:,nj-2)%dx1

    mg1(:,nj) % dx2 = 2 * mg1(:,njm)%dx2 - mg1(:,nj-2)%dx2
    mg2(:,nj) % dx2 = 2 * mg2(:,njm)%dx2 - mg2(:,nj-2)%dx2
    mg3(:,nj) % dx2 = 2 * mg3(:,njm)%dx2 - mg3(:,nj-2)%dx2
    mg4(:,nj) % dx2 = 2 * mg4(:,njm)%dx2 - mg4(:,nj-2)%dx2

    mg1(:,nj) % h1 = 2 * mg1(:,njm)%h1 - mg1(:,nj-2)%h1
    mg2(:,nj) % h1 = 2 * mg2(:,njm)%h1 - mg2(:,nj-2)%h1
    mg3(:,nj) % h1 = 2 * mg3(:,njm)%h1 - mg3(:,nj-2)%h1
    mg4(:,nj) % h1 = 2 * mg4(:,njm)%h1 - mg4(:,nj-2)%h1
  end if

  ! values determined by others !{{{2
  mg1 % h2 = a
  mg2 % h2 = a
  mg3 % h2 = a
  mg4 % h2 = a

  mg1 % j  = mg1%h1 * mg1%h2
  mg2 % j  = mg2%h1 * mg2%h2
  mg3 % j  = mg3%h1 * mg3%h2
  mg4 % j  = mg4%h1 * mg4%h2
end subroutine calc_metric

subroutine calc_vgrid (gu, gw) !{{{1
  ! calc. vertical grid info
  use mod_arrays, only: type_gv
  use mod_master, only: glo_gvu, glo_gvw

  type (type_gv) :: gu(:), gw(:)

  gu(:) % z  = mympi_div (glo_gvu % z, 'z')
  gw(:) % z  = mympi_div (glo_gvw % z, 'z')

  gu(:) % x3 = mympi_div (glo_gvu % x3, 'z')
  gw(:) % x3 = mympi_div (glo_gvw % x3, 'z')

  ! sea surface
  if ( gpw % gu == 1 ) then
    gu(1)%z = 0.0
    gw(1)%z = 0.0
    
    gu(1)%x3 = 0.0
    gw(1)%x3 = 0.0
  end if

  if ( gpw % gl == glo_nk ) then
    gu(nk) % z = 2 * gu(nkm)%z - gu(nk-2)%z
    gw(nk) % z = 2 * gw(nkm)%z - gw(nk-2)%z

    gu(nk) % x3 = 2 * gu(nkm)%x3 - gu(nk-2)%x3
    gw(nk) % x3 = 2 * gw(nkm)%x3 - gw(nk-2)%x3
  end if

end subroutine calc_vgrid

subroutine calc_pbu (phu) !{{{1
  ! calc. sea bottom pressure phu at g3-grid
  real (kind=wp), intent(in) :: phu(ni, nj)

  real (kind=wp) :: ra(ni, nj, nk)
  real (kind=wp) :: dp(nk)

  dp(:) = 0.0
  dp(2:nkm) = gvw(2:nkm)%x3 - gvw(1:nk-2)%x3
  call mympi_swpbnd (dp, 'z')

  ra(:,:,:) = umsk * spread(spread(dp, 1, nj), 1, ni)
  call mympi_allreduce_z ( sum(ra(:,:,2:nkm), 3), phu )
end subroutine calc_pbu

subroutine chk( ista ) !{{{1
  ! check state of allocate array 

  integer, intent(in) ::  ista

  if ( ista /= 0 ) then
    write(*,*) 'Allocate array failed. Stop'
    stop 2
  end if
end subroutine chk

end program main !{{{1
!-------------------------------------------------------{{{1
! vim:fdm=marker:fdl=0:
! vim:foldtext=getline(v\:foldstart).'...'.(v\:foldend-v\:foldstart):
